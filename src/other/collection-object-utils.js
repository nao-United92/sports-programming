/**
 * Creates an object with the same keys as `obj` and values generated by running
 * each own enumerable string keyed property of `obj` thru `iteratee`.
 * @param {object} obj The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {object} Returns the new mapped object.
 */
export function mapObject(obj, iteratee) {
  const result = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result[key] = iteratee(obj[key], key, obj);
    }
  }
  return result;
}

/**
 * Iterates over properties of `obj`, returning an object of all properties
 * `predicate` returns truthy for.
 * @param {object} obj The object to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {object} Returns the new filtered object.
 */
export function filterObject(obj, predicate) {
  const result = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (predicate(obj[key], key, obj)) {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

/**
 * Checks if `value` is an empty object, collection, or string.
 * @param {*} value The value to inspect.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 */
export function isEmpty(value) {
  if (value === null || value === undefined) {
    return true;
  }

  if (typeof value === 'string' || Array.isArray(value)) {
    return value.length === 0;
  }

  if (value instanceof Map || value instanceof Set) {
    return value.size === 0;
  }

  if (typeof value === 'object') {
    return Object.keys(value).length === 0;
  }

  return false;
}

/**
 * Creates an object composed of the picked `object` properties.
 * @param {object} object The source object.
 * @param {Array<string>} paths The property keys to pick.
 * @returns {object} Returns the new object.
 */
export function pick(object, paths) {
  const result = {};
  if (object === null || typeof object !== 'object') {
    return result;
  }

  for (const path of paths) {
    if (Object.prototype.hasOwnProperty.call(object, path)) {
      result[path] = object[path];
    }
  }
  return result;
}

/**
 * The opposite of `pick`; this method creates an object composed of the own
 * and inherited enumerable property paths of `object` that are not omitted.
 * @param {object} object The source object.
 * @param {Array<string>} paths The property keys to omit.
 * @returns {object} Returns the new object.
 */
export function omit(object, paths) {
  const result = { ...object };
  if (object === null || typeof object !== 'object') {
    return {};
  }

  for (const path of paths) {
    delete result[path];
  }
  return result;
}
