/**
 * Creates an object with the same keys as `obj` and values generated by running
 * each own enumerable string keyed property of `obj` thru `iteratee`.
 * @param {object} obj The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {object} Returns the new mapped object.
 */
export function mapObject(obj, iteratee) {
  const result = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result[key] = iteratee(obj[key], key, obj);
    }
  }
  return result;
}

/**
 * Iterates over properties of `obj`, returning an object of all properties
 * `predicate` returns truthy for.
 * @param {object} obj The object to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {object} Returns the new filtered object.
 */
export function filterObject(obj, predicate) {
  const result = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (predicate(obj[key], key, obj)) {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

/**
 * Checks if `value` is an empty object, collection, or string.
 * @param {*} value The value to inspect.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 */
export function isEmpty(value) {
  if (value === null || value === undefined) {
    return true;
  }

  if (typeof value === 'string' || Array.isArray(value)) {
    return value.length === 0;
  }

  if (value instanceof Map || value instanceof Set) {
    return value.size === 0;
  }

  if (typeof value === 'object') {
    return Object.keys(value).length === 0;
  }

  return false;
}

/**
 * Creates an object composed of the picked `object` properties.
 * @param {object} object The source object.
 * @param {Array<string>} paths The property keys to pick.
 * @returns {object} Returns the new object.
 */
export function pick(object, paths) {
  const result = {};
  if (object === null || typeof object !== 'object') {
    return result;
  }

  for (const path of paths) {
    if (Object.prototype.hasOwnProperty.call(object, path)) {
      result[path] = object[path];
    }
  }
  return result;
}

/**
 * The opposite of `pick`; this method creates an object composed of the own
 * and inherited enumerable property paths of `object` that are not omitted.
 * @param {object} object The source object.
 * @param {Array<string>} paths The property keys to omit.
 * @returns {object} Returns the new object.
 */
export const omit = (obj, keys) => {
  const newObj = { ...obj };
  keys.forEach(key => delete newObj[key]);
  return newObj;
};

/**
 * Extracts a list of property values from a collection of objects.
 * @param {Array<Object>} collection The collection of objects.
 * @param {string} key The property key to extract.
 * @returns {Array} The array of property values.
 */
export const pluck = (collection, key) => {
  if (!Array.isArray(collection)) {
    return [];
  }
  return collection.map(item => (item !== null && item !== undefined ? item[key] : undefined));
};

export const deepClone = (obj) => {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }

  if (Array.isArray(obj)) {
    const arrCopy = [];
    for (let i = 0; i < obj.length; i++) {
      arrCopy[i] = deepClone(obj[i]);
    }
    return arrCopy;
  }

  const objCopy = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      objCopy[key] = deepClone(obj[key]);
    }
  }
  return objCopy;
};
