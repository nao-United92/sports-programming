/**
 * Creates an object with the same keys as `obj` and values generated by running
 * each own enumerable string keyed property of `obj` thru `iteratee`.
 * @param {object} obj The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {object} Returns the new mapped object.
 */
export function mapObject(obj, iteratee) {
  const result = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result[key] = iteratee(obj[key], key, obj);
    }
  }
  return result;
}

/**
 * Iterates over properties of `obj`, returning an object of all properties
 * `predicate` returns truthy for.
 * @param {object} obj The object to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {object} Returns the new filtered object.
 */
export function filterObject(obj, predicate) {
  const result = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (predicate(obj[key], key, obj)) {
        result[key] = obj[key];
      }
    }
  }
  return result;
}

/**
 * Checks if `value` is an empty object, collection, or string.
 * @param {*} value The value to inspect.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 */
export function isEmpty(value) {
  if (value === null || value === undefined) {
    return true;
  }

  if (typeof value === 'string' || Array.isArray(value)) {
    return value.length === 0;
  }

  if (value instanceof Map || value instanceof Set) {
    return value.size === 0;
  }

  if (typeof value === 'object') {
    return Object.keys(value).length === 0;
  }

  return false;
}
