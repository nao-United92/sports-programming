/**
 * Creates an object with the same values as the provided object and keys generated by running each own enumerable string keyed property of the object through the iteratee.
 * @param {object} obj The object to iterate over.
 * @param {Function} fn The iteratee to transform keys.
 * @returns {object} Returns the new object.
 */
export const mapKeys = (obj, fn) =>
  Object.keys(obj).reduce((acc, key) => {
    acc[fn(obj[key], key, obj)] = obj[key];
    return acc;
  }, {});

/**
 * Creates an object with the same keys as the provided object and values generated by running each own enumerable string keyed property of the object through the iteratee.
 * @param {object} obj The object to iterate over.
 * @param {Function} fn The iteratee to transform values.
 * @returns {object} Returns the new object.
 */
export const mapValues = (obj, fn) =>
  Object.keys(obj).reduce((acc, key) => {
    acc[key] = fn(obj[key], key, obj);
    return acc;
  }, {});

/**
 * Creates an object composed of the own and inherited enumerable property paths of object that are not omitted.
 * @param {object} obj The source object.
 * @param {string[]} keys The property paths to omit.
 * @returns {object} Returns the new object.
 */
export const omit = (obj, keys) => {
  const newObj = { ...obj };
  keys.forEach(key => {
    delete newObj[key];
  });
  return newObj;
};

/**
 * Creates an object composed of the picked object properties.
 * @param {object} obj The source object.
 * @param {string[]} keys The property paths to pick.
 * @returns {object} Returns the new object.
 */
export const pick = (obj, keys) => {
  const newObj = {};
  keys.forEach(key => {
    if (key in obj) {
      newObj[key] = obj[key];
    }
  });
  return newObj;
};

/**
 * Checks if `key` is a direct or inherited property of `object`.
 * @param {object} obj The object to query.
 * @param {string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
export const has = (obj, key) => {
  return obj != null && Object.prototype.hasOwnProperty.call(obj, key);
};

/**
 * Creates an object with inverted keys and values.
 * @param {object} obj The object to invert.
 * @returns {object} Returns the new inverted object.
 */
export const invert = (obj) => {
  const newObj = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      newObj[obj[key]] = key;
    }
  }
  return newObj;
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 * @param {object} obj The object to query.
 * @returns {string[]} Returns the array of property names.
 */
export const keysIn = (obj) => {
  const result = [];
  for (const key in obj) {
    result.push(key);
  }
  return result;
};
